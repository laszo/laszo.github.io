<html>

<head>
    <meta charset="utf-8">
    <title>理解Flask的BluePrint：子模块和框架糖 - Lv Xiaoyu `Site</title>
    <link rel="stylesheet" href="../../static/css/bootstrap.min.css?v=1" />
    <link rel="stylesheet" href="../../static/css/mp.css?v=1" />
    <link rel="stylesheet" href="../../static/css/codehilite.css?v=1" />
</head>

<body>
    <div class="container">
        <div class="blog-header">
            <a href="../../index.html">
                <h1>Lv Xiaoyu `Site</h1>
            </a>
        </div>

        <div class="col-sm-9">
            <h3 class="blog-post-title">理解Flask的BluePrint：子模块和框架糖</h3>

            <div class="post-content">
                <p>BluePrint（下称蓝图）是Flask框架里的一个重要概念，本文先从使用的角度介绍蓝图，然后介绍使用蓝图时代码的组织方式，最后会从Flask源代码的角度分析蓝图的实现，最终总结出它的本质。</p>
<p>BluePrint这个词在其他Python框架里没有见到过，
由于用了这个词，初学者可能对它的含义有点模糊，初次接触可以笼统的把它看做是应用的子模块。基本上，
如果你要写稍微复杂一点的网站，不可能把所有代码都放在一个py文件里，不可避免的要把网站的各种功能或组件模块化。类比于Django中的application，如果你开发了一个Web网站：</p>
<ul>
<li>Django把网站的整体称为project（项目），把project中的子模块称为application（应用）</li>
<li>Flask把网站的整体称为application（应用），把application中的子模块称为blueprint（蓝图）</li>
</ul>
<h4 id='blue_basic'>蓝图的基本使用</h4>

<p>还是先从使用的角度来看它，假设你已经知道了一个最简单的Flask的demo怎么写：</p>
<div class="codehilite"><pre><span></span><span class="c1"># app.py</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Hello, World!&#39;</span>
</pre></div>


<p>写一个蓝图与写一个应用差不多，区别是用到了flask.Blueprint，而非flask.Flask：</p>
<div class="codehilite"><pre><span></span><span class="c1"># book.py</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Blueprint</span>

<span class="n">book</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s1">&#39;book&#39;</span><span class="p">,</span> <span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@book.route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">page</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;This is Book page.&#39;</span>
</pre></div>


<p>创建一个Flask的实例需要：</p>
<div class="codehilite"><pre><span></span>app = Flask(__name__)
</pre></div>


<p>创建一个Blueprint的实例则需要：</p>
<div class="codehilite"><pre><span></span>book = Blueprint(&#39;book&#39;, __name__)
</pre></div>


<p>为你的函数注册路由需要装饰器：</p>
<div class="codehilite"><pre><span></span>@app.route(&#39;/&#39;)
</pre></div>


<p>在蓝图中为你的函数添加注册路由则需要：</p>
<div class="codehilite"><pre><span></span>@book.route(&#39;/&#39;)
</pre></div>


<p>然后我们把book.py放在项目根目录的book文件夹中，在book文件夹下面新建<code>__init__.py</code>的空文件。
目前项目的结构像下面这样：</p>
<div class="codehilite"><pre><span></span>.
├── app.py
└── book
    ├── __init__.py
    └── book.py
</pre></div>


<p>然后我们就可以在app.py中<span id='ref_book_blue'>注册book蓝图</span>了：</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">book.book</span> <span class="kn">import</span> <span class="n">book</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">book</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Hello, World!&#39;</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>


<p>然后我们运行项目，用浏览器打开 <a href="http://127.0.0.1:5000">http://127.0.0.1:5000</a> 会发现，
浏览器上显示的是book函数返回的<code>This is Book page.</code>而非hello_world函数返回的<code>Hello, World!</code>。
这说明：</p>
<ol>
<li>book蓝图的确注册到了我们的项目中</li>
<li>项目整体的路由配置有冲突，book的路由覆盖（截获）了hello_world的路由</li>
</ol>
<p>为了解决第二个问题，我们需要给register_blueprint传递url_prefix参数，将注册路由的代码修改为：</p>
<div class="codehilite"><pre><span></span><span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">book</span><span class="p">,</span> <span class="n">url_prefix</span><span class="o">=</span><span class="s1">&#39;/book&#39;</span><span class="p">)</span>
</pre></div>


<p>然后再次运行项目，可以发现得到了期望的结果：</p>
<ul>
<li>打开 <a href="http://127.0.0.1:5000">http://127.0.0.1:5000</a> 得到Hello, World!</li>
<li>打开 <a href="http://127.0.0.1:5000/book">http://127.0.0.1:5000/book</a> 得到This is Book page.</li>
</ul>
<h4 id='comp_blu'>在蓝图中使用其他Flask功能</h4>

<p>正常的项目当然不可能仅仅返回一个字符串，需要用到模板、静态文件等资源，你可以像在Flask应用级别中那样使用。下面是Flask项目源码中的例子<a href="https://github.com/pallets/flask/tree/master/examples/blueprintexample">blueprintexample</a>的simple_page.py代码：</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Blueprint</span><span class="p">,</span> <span class="n">render_template</span><span class="p">,</span> <span class="n">abort</span>
<span class="kn">from</span> <span class="nn">jinja2</span> <span class="kn">import</span> <span class="n">TemplateNotFound</span>

<span class="n">simple_page</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s1">&#39;simple_page&#39;</span><span class="p">,</span> <span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">template_folder</span><span class="o">=</span><span class="s1">&#39;templates&#39;</span><span class="p">)</span>

<span class="nd">@simple_page.route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;page&#39;</span><span class="p">:</span> <span class="s1">&#39;index&#39;</span><span class="p">})</span>
<span class="nd">@simple_page.route</span><span class="p">(</span><span class="s1">&#39;/&lt;page&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">page</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;pages/</span><span class="si">%s</span><span class="s1">.html&#39;</span> <span class="o">%</span> <span class="n">page</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">TemplateNotFound</span><span class="p">:</span>
        <span class="n">abort</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
</pre></div>


<p>基本上，除了把Flask类改为了Blueprint类，其余地方并无太大区别。</p>
<h4 id='code_stru'>如何组织代码</h4>

<p><a href="https://exploreflask.com/en/latest/blueprints.html">Explore Flask</a>一书中提到，对蓝图的代码组织，分为两种：</p>
<ul>
<li>功能式架构，Functional structure</li>
<li>分区式架构，Divisional structure</li>
</ul>
<p>在功能式架构中，所有的模板、静态文件等资源放置在项目全局的文件夹内，仅蓝图中的函数代码本身放置在模块中。
加入你的项目有admin、home、control_panel等模块，功能式架构的文件组织如下：</p>
<div class="codehilite"><pre><span></span>yourapp/
    __init__.py
    static/
    templates/
        home/
        control_panel/
        admin/
    views/
        __init__.py
        home.py
        control_panel.py
        admin.py
    models.py
</pre></div>


<p>对应的，分区式架构中每一个蓝图都有自己的资源文件夹：</p>
<div class="codehilite"><pre><span></span>yourapp/
    __init__.py
    admin/
        __init__.py
        views.py
        static/
        templates/
    home/
        __init__.py
        views.py
        static/
        templates/
    control_panel/
        __init__.py
        views.py
        static/
        templates/
    models.py
</pre></div>


<p>具体采用哪种方式，主要看这些蓝图之间的关系是否独立。如果你的网站整体使用同一的风格，所有的模板文件都拓展自一个基础的模板文件，可以采用功能式架构。相反，如果你的网站的子模块的外观不太相似，比如网站前台使用一种风格，后台管理界面使用另一种风格，就可以采用分区式架构，把这些资源文件放在各自蓝图下的文件夹，便于分开维护。分区式架构架构显然也便于蓝图在不同应用间的复用。</p>
<h4 id='blu_src'>从源码看蓝图的实现</h4>

<p>简单来看flask.Flask类和flask.Blueprint类的API文档，发现它们的相似之处：</p>
<ul>
<li>
<p>两者的构造函数有很多同名的参数，比如import_name、static_folder、static_url_path、template_folder、root_path等</p>
</li>
<li>
<p>两者有很多同名方法，比如：route、add_url_rule、before_request、after_request等等。</p>
</li>
</ul>
<p>下面来看<a href="https://github.com/pallets/flask/blob/master/flask/blueprints.py">blueprints.py</a>的源码，从实现的角度去追踪：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Blueprint</span><span class="p">(</span><span class="n">_PackageBoundObject</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deferred_functions</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_got_registered_once</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">warn_on_modifications</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
            <span class="n">warn</span><span class="p">(</span><span class="ne">Warning</span><span class="p">(</span><span class="s1">&#39;The blueprint was already registered once &#39;</span>
                        <span class="s1">&#39;but is getting modified now.  These changes &#39;</span>
                        <span class="s1">&#39;will not show up.&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deferred_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">record_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">first_registration</span><span class="p">:</span>
                <span class="n">func</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">func</span><span class="p">))</span>
</pre></div>


<p>record方法用于向deferred_functions成员中添加func，record_once确保这种添加只执行一次。</p>
<p>我们看Blueprint类的大部分方法的源码，会发现它都调用了record_once：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Blueprint</span><span class="p">(</span><span class="n">_PackageBoundObject</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">before_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record_once</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">before_request_funcs</span>
            <span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">f</span>
</pre></div>


<p>也就是说，在执行Blueprint.before_request(f)时，实际做的动作是调用了record_once，
最终把参数<code>f</code>添加到了deferred_functions成员中。</p>
<p>那么这个deferred_functions成员是干什么用的呢？</p>
<div class="codehilite"><pre><span></span><span class="c1"># blueprints.py</span>
<span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">first_registration</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="n">deferred</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deferred_functions</span><span class="p">:</span>
        <span class="n">deferred</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>


<p>可以看到，deferred_functions保存的这些func，会在register方法中得到执行。
再看<a href="https://github.com/pallets/flask/blob/master/flask/app.py">app.py</a>的源码发现，register方法会在Flask.register_blueprint方法中被调用：</p>
<div class="codehilite"><pre><span></span><span class="c1"># app.py</span>
<span class="k">class</span> <span class="nc">Flask</span><span class="p">(</span><span class="n">_PackageBoundObject</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">register_blueprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blueprint</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="n">blueprint</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">first_registration</span><span class="p">)</span>
</pre></div>


<p>这里的register_blueprint方法就是我们在<a href="#ref_book_blue">注册book蓝图</a>中看到的代码：</p>
<div class="codehilite"><pre><span></span><span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">book</span><span class="p">)</span>
</pre></div>


<h4 id='blue_all'>总结</h4>

<p>到这里可以总结出：在执行Blueprint实例的某些方法时，该实例会把该方法保存起来，稍后在向Flask对象注册这个蓝图时，Flask对象会执行这些方法。一般来说这些方法都是用于注册某些前处理、后处理函数、或者传递某些配置项。</p>
<p>也就是说，Blueprint类的大部分方法，本质上就是传递给了Flask类的同名方法，这就解释了为什么Blueprint对象用起来和Flask对象差不多。Blueprint实际上是对Flask类的一部分功能的再次包装，通过这些包装，
既能够实现Web应用的模块化，又没有增加使用的难度。</p>
<p>所以，从Web开发者的角度来看，蓝图就是Flask项目的子模块，从实现的角度来看，蓝图就是Flask为我们提供的框架糖。</p>
            </div>
        </div>
        <div class="col-md-3" role="complementary">
            <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix">
                
                <h3>目录</h3>
                
                <ul class="nav bs-docs-sidenav">
                    
                    <li class="">
                        <a href="#blue_basic">蓝图的基本使用</a>
                    </li>
                    <!--<li class="">
                        <a href="#download">下载</a>
                    </li>
                    <li class="">
                        <a href="#third-parties">对第三方组件的支持</a>
                    </li>
                    <li class="active">
                        <a href="#accessibility">可访问性</a>
                    </li>
                    <li>
                        <a href="#license-faqs">许可证 FAQ</a>
                    </li>
                    <li>
                        <a href="#translations">文档翻译</a>
                    </li>-->
                    
                    <li class="">
                        <a href="#comp_blu">在蓝图中使用其他Flask功能</a>
                    </li>
                    <!--<li class="">
                        <a href="#download">下载</a>
                    </li>
                    <li class="">
                        <a href="#third-parties">对第三方组件的支持</a>
                    </li>
                    <li class="active">
                        <a href="#accessibility">可访问性</a>
                    </li>
                    <li>
                        <a href="#license-faqs">许可证 FAQ</a>
                    </li>
                    <li>
                        <a href="#translations">文档翻译</a>
                    </li>-->
                    
                    <li class="">
                        <a href="#code_stru">如何组织代码</a>
                    </li>
                    <!--<li class="">
                        <a href="#download">下载</a>
                    </li>
                    <li class="">
                        <a href="#third-parties">对第三方组件的支持</a>
                    </li>
                    <li class="active">
                        <a href="#accessibility">可访问性</a>
                    </li>
                    <li>
                        <a href="#license-faqs">许可证 FAQ</a>
                    </li>
                    <li>
                        <a href="#translations">文档翻译</a>
                    </li>-->
                    
                    <li class="">
                        <a href="#blu_src">从源码看蓝图的实现</a>
                    </li>
                    <!--<li class="">
                        <a href="#download">下载</a>
                    </li>
                    <li class="">
                        <a href="#third-parties">对第三方组件的支持</a>
                    </li>
                    <li class="active">
                        <a href="#accessibility">可访问性</a>
                    </li>
                    <li>
                        <a href="#license-faqs">许可证 FAQ</a>
                    </li>
                    <li>
                        <a href="#translations">文档翻译</a>
                    </li>-->
                    
                    <li class="">
                        <a href="#blue_all">总结</a>
                    </li>
                    <!--<li class="">
                        <a href="#download">下载</a>
                    </li>
                    <li class="">
                        <a href="#third-parties">对第三方组件的支持</a>
                    </li>
                    <li class="active">
                        <a href="#accessibility">可访问性</a>
                    </li>
                    <li>
                        <a href="#license-faqs">许可证 FAQ</a>
                    </li>
                    <li>
                        <a href="#translations">文档翻译</a>
                    </li>-->
                    
                </ul>              
            </nav>
        </div>
    </div>
</body>

</html>