<html>
<head>
    <meta charset="utf-8">
    <title>WSGI的Server端分析 - Lv Xiaoyu `Site</title>
    <link rel="stylesheet" href="../../static/css/bootstrap.min.css?v=1" />
    <link rel="stylesheet" href="../../static/css/mp.css?v=1" />
    <link rel="stylesheet" href="../../static/css/codehilite.css?v=1" />
</head>
<body>
    <div class="container">
        <div class="blog-header">
            <a href="../../index.html"><h1>Lv Xiaoyu `Site</h1></a>
        </div>

        <h3 class="blog-post-title">WSGI的Server端分析</h3>

        <div class="post-content">
            <p>我们都知道写一个WSGI的application是非常简单的：</p>
<div class="codehilite"><pre><span></span>def app(env, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-type&#39;, &#39;text/plain&#39;)])
    return &#39;Hello, world!\n&#39;
</pre></div>


<p>这篇文章已经探讨了WSGI的application这一部分的特点，现在我们来关心服务器如何承载application，我们从python标准库wsgiref来研究这个过程。虽然wsgiref作为生产环境的服务器是不够的，但是用来研究基本的原理已足够。如下代码就可以运行起server：</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="kn">import</span> <span class="n">make_server</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">,</span> <span class="n">myapp</span><span class="o">.</span><span class="n">app</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>


<p>make_server的代码：</p>
<div class="codehilite"><pre><span></span>def make_server(
    host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler
):
    server = server_class((host, port), handler_class)
    server.set_app(app)
    return server
</pre></div>


<p>核心是<code>WSGIServer</code>和<code>WSGIRequestHandler</code>两个类。先从Server来看：</p>
<div class="codehilite"><pre><span></span><span class="kr">class</span> <span class="nx">WSGIServer</span><span class="p">(</span><span class="nx">HTTPServer</span><span class="p">)</span><span class="o">:</span>

    <span class="s2">&quot;&quot;&quot;BaseHTTPServer that implements the Python WSGI protocol&quot;&quot;&quot;</span>

    <span class="nx">application</span> <span class="o">=</span> <span class="nx">None</span>

    <span class="nx">def</span> <span class="nx">server_bind</span><span class="p">(</span><span class="nx">self</span><span class="p">)</span><span class="o">:</span>
        <span class="s2">&quot;&quot;&quot;Override server_bind to store the server name.&quot;&quot;&quot;</span>
        <span class="nx">HTTPServer</span><span class="p">.</span><span class="nx">server_bind</span><span class="p">(</span><span class="nx">self</span><span class="p">)</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">setup_environ</span><span class="p">()</span>

    <span class="nx">def</span> <span class="nx">setup_environ</span><span class="p">(</span><span class="nx">self</span><span class="p">)</span><span class="o">:</span>
        <span class="err">#</span> <span class="nx">Set</span> <span class="nx">up</span> <span class="nx">base</span> <span class="nx">environment</span>
        <span class="nx">env</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">base_environ</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="nx">env</span><span class="p">[</span><span class="s1">&#39;SERVER_NAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">server_name</span>
        <span class="nx">env</span><span class="p">[</span><span class="s1">&#39;GATEWAY_INTERFACE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;CGI/1.1&#39;</span>
        <span class="nx">env</span><span class="p">[</span><span class="s1">&#39;SERVER_PORT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">str</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">server_port</span><span class="p">)</span>
        <span class="nx">env</span><span class="p">[</span><span class="s1">&#39;REMOTE_HOST&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
        <span class="nx">env</span><span class="p">[</span><span class="s1">&#39;CONTENT_LENGTH&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
        <span class="nx">env</span><span class="p">[</span><span class="s1">&#39;SCRIPT_NAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="nx">def</span> <span class="nx">get_app</span><span class="p">(</span><span class="nx">self</span><span class="p">)</span><span class="o">:</span>
        <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">application</span>

    <span class="nx">def</span> <span class="nx">set_app</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span><span class="nx">application</span><span class="p">)</span><span class="o">:</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">application</span> <span class="o">=</span> <span class="nx">application</span>
</pre></div>


<p>其继承自<code>BaseHTTPServer.HTTPServer</code>，添加了如下几个方法：</p>
<ul>
<li>get_app和set_app：设置或获取application</li>
<li>server_bind，使用的是父类的server_bind，多执行了setup_environ这一步</li>
<li>setup_environ，设置env变量的一些基本字段，保存在自己的base_environ成员中</li>
</ul>
<p>追踪到<code>HTTPServer</code>:</p>
<div class="codehilite"><pre><span></span><span class="kr">class</span> <span class="nx">HTTPServer</span><span class="p">(</span><span class="nx">SocketServer</span><span class="p">.</span><span class="nx">TCPServer</span><span class="p">)</span><span class="o">:</span>

    <span class="nx">allow_reuse_address</span> <span class="o">=</span> <span class="mi">1</span>    <span class="err">#</span> <span class="nx">Seems</span> <span class="nx">to</span> <span class="nx">make</span> <span class="nx">sense</span> <span class="k">in</span> <span class="nx">testing</span> <span class="nx">environment</span>

    <span class="nx">def</span> <span class="nx">server_bind</span><span class="p">(</span><span class="nx">self</span><span class="p">)</span><span class="o">:</span>
        <span class="s2">&quot;&quot;&quot;Override server_bind to store the server name.&quot;&quot;&quot;</span>
        <span class="nx">SocketServer</span><span class="p">.</span><span class="nx">TCPServer</span><span class="p">.</span><span class="nx">server_bind</span><span class="p">(</span><span class="nx">self</span><span class="p">)</span>
        <span class="nx">host</span><span class="p">,</span> <span class="nx">port</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">socket</span><span class="p">.</span><span class="nx">getsockname</span><span class="p">()[</span><span class="o">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">server_name</span> <span class="o">=</span> <span class="nx">socket</span><span class="p">.</span><span class="nx">getfqdn</span><span class="p">(</span><span class="nx">host</span><span class="p">)</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">server_port</span> <span class="o">=</span> <span class="nx">port</span>
</pre></div>


<p>继承自<code>SocketServer.TCPServer</code>，只添加了一个方法<code>server_bind</code>。这方法先是调用其父类的同名方法<code>TCPServer.server_bind</code>，然后设置了自身的server_name和server_port成员。</p>
<p>到这里可以发现，从<code>WSGIServer</code>到<code>BaseHttpServer</code>，并不包含什么处理流程，要研究的东西还在后面。来看TCPServer，由于它的代码太多，我们一部分一部分来研究：</p>
<p>class TCPServer(BaseServer):</p>
<div class="codehilite"><pre><span></span>def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True):
    BaseServer.__init__(self, server_address, RequestHandlerClass)
    self.socket = socket.socket(self.address_family, self.socket_type)
    if bind_and_activate:
        try:
            self.server_bind()
            self.server_activate()
        except:
            self.server_close()
            raise
</pre></div>


<p>TCPServer继承自BaseServer，它的构造方法做了如下几件事：</p>
<ul>
<li>调用父类BaseServer的构造器，传入地址和处理类，也就是说到了Baserver的代码层面是知道处理类的存在的</li>
<li>初始化它的成员socket</li>
<li>如果bind_and_activate为True（默认为True），调用server_bind和server_activate，看名字就知道，分别是绑定和激活服务器</li>
</ul>
<p>来看server_bind：</p>
<div class="codehilite"><pre><span></span>def server_bind(self):
    if self.allow_reuse_address:
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    self.socket.bind(self.server_address)
    self.server_address = self.socket.getsockname()
</pre></div>


<p>核心逻辑是执行socket.bind，这是使用socket必要的第一步。其次是把地址存储在自身的server_address成员上。</p>
<p>来看server_activate：</p>
<div class="codehilite"><pre><span></span>def server_activate(self):
    self.socket.listen(self.request_queue_size)
</pre></div>


<p>单纯执行socket.listen。看到这里我们可以发现，TCPServer的构造方法，除了调用父类的构造方法之外，主要就是完成了对socket的初始化和监听，相当于：</p>
<div class="codehilite"><pre><span></span>self.socket = socket.socket()
self.socket.bind(address)
self.socket.listen(self.request_queue_size)
</pre></div>


<p>这几个方法看完，我们一次性的看TCPServer的其他方法：</p>
<div class="codehilite"><pre><span></span>def server_close(self):
    self.socket.close()

def fileno(self):
    return self.socket.fileno()

def get_request(self):
    return self.socket.accept()

def shutdown_request(self, request):
    try:
        request.shutdown(socket.SHUT_WR)
    except socket.error:
        pass
    self.close_request(request)

def close_request(self, request):
    request.close()
</pre></div>


<p><code>server_close</code>和<code>fileno</code>这两个方法，就是纯粹调用自身socket成员的对应方法。
<code>shutdown_request</code>和<code>close_request</code>，分别调用socket的<code>shutdown</code>和<code>close</code>方法。
至于<code>get_request</code>，则是返回了socket的accept方法的返回值，我们知道这是一个pair：(conn, address)：</p>
<ul>
<li>coon，是一个新的socket对象，代表原来的socket与另一端（客户端）的连接</li>
<li>address，代表另一端的地址</li>
</ul>
<p>到这里TCPServer的代码就看完了，我们可以说，它其实只有如下几点：</p>
<ul>
<li>就是对socket的一层包装</li>
<li>附加了简单的错误处理</li>
<li>存储部分对象</li>
</ul>
<p>至于我们最关心的服务端的处理流程，看来还要进一步再往下看<code>BaseServer</code>，仍然分为几个部分来看：</p>
<div class="codehilite"><pre><span></span><span class="kr">class</span> <span class="nx">BaseServer</span>:
    <span class="kt">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">server_address</span><span class="p">,</span> <span class="nx">RequestHandlerClass</span><span class="p">)</span><span class="o">:</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">server_address</span> <span class="o">=</span> <span class="nx">server_address</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">RequestHandlerClass</span> <span class="o">=</span> <span class="nx">RequestHandlerClass</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">__is_shut_down</span> <span class="o">=</span> <span class="nx">threading</span><span class="p">.</span><span class="nx">Event</span><span class="p">()</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">__shutdown_request</span> <span class="o">=</span> <span class="nx">False</span>
</pre></div>


<p>BaseServer终于没有再继承其他类了，它的构造方法做了如下几件事：</p>
<ul>
<li>存储server_address和RequestHandlerClass成员</li>
<li>调用<code>threading.Event</code>，这个方法生成了一个新的Event对象，用于在线程间传输信号，我们可以推论BaseServer使用了多线程</li>
<li>初始化__shutdown_request为False</li>
</ul>
<p>到这里，似乎没有了追踪的线索。我们可以回溯到最初的代码：</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="kn">import</span> <span class="n">make_server</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">,</span> <span class="n">myapp</span><span class="o">.</span><span class="n">app</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>


<p>Server调用了<code>serve_forever</code>方法，这个是Server的核心逻辑。但在此之前我们先要看一下SocketServer模块中定义的一个函数<code>_eintr_retry</code>的代码：</p>
<div class="codehilite"><pre><span></span>def _eintr_retry(func, *args):
    &quot;&quot;&quot;restart a system call interrupted by EINTR&quot;&quot;&quot;
    while True:
        try:
            return func(*args)
        except (OSError, select.error) as e:
            if e.args[0] != errno.EINTR:
                raise
</pre></div>


<p>这个函数的逻辑是运行指定的<code>func</code>，如果func能够成功运行则直接返回func的返回值，如果有异常就捕获异常，如果捕获的异常是<code>errno.EINTR</code>就抛出异常。如果捕获的异常不是<code>errno.EINTR</code>，就会进行下一次循环。</p>
<p>总的来说<code>_eintr_retry</code>的逻辑就是反复尝试执行func一直到执行成功、遇到<code>errno.EINTR</code>为止，这个异常代表系统中断（<code>Interrupted system call</code>）。</p>
<p>下面来看<code>serve_forever</code>的代码：</p>
<div class="codehilite"><pre><span></span>def serve_forever(self, poll_interval=0.5):
    self.__is_shut_down.clear()
    try:
        while not self.__shutdown_request:
            r, w, e = _eintr_retry(select.select, [self], [], [], poll_interval)
            if self in r:
                self._handle_request_noblock()
    finally:
        self.__shutdown_request = False
        self.__is_shut_down.set()
</pre></div>


<p><code>serve_forever</code>方法是服务器的核心逻辑，它的作用可以从它的第一句注释来概括：</p>
<blockquote>
<p>Handle one request at a time until shutdown.
（每次处理一个请求，直到关闭。）</p>
</blockquote>
<p>方法先是执行<code>self.__is_shut_down.clear()</code>，从前面BaseServer的构造方法中我们知道<code>__is_shut_down</code>是一个<code>threading.Event</code>，使用这个成员的代码我们后面才会看到。</p>
<p>然后的逻辑在就是一直监听客户端请求，并处理请求。监听请求使用的是<code>select.select</code>，这个我们在前面的文章里已经介绍过。处理请求使用<code>_handle_request_noblock</code>方法，下面来看这个方法的代码：</p>
<div class="codehilite"><pre><span></span>def _handle_request_noblock(self):
    try:
        request, client_address = self.get_request()
    except socket.error:
        return
    if self.verify_request(request, client_address):
        try:
            self.process_request(request, client_address)
        except:
            self.handle_error(request, client_address)
            self.shutdown_request(request)
</pre></div>


<p>去除捕获和异常处理的部分，我们可以认为代码的逻辑如下：</p>
<div class="codehilite"><pre><span></span>request, client_address = self.get_request()
if self.verify_request(request, client_address):
    self.process_request(request, client_address)
</pre></div>


<p>即：</p>
<ol>
<li>获取请求：get_request</li>
<li>验证请求：verify_request</li>
<li>处理请求：process_request</li>
</ol>
<p>在BaseServer中并无get_request这个方法，我们在前面已经看过TCPServer类中的这个方法，就是单纯的返回<code>socket.accept()</code>的返回值。</p>
<p>BaseServer中的verify_request方法非常简单，单纯返回True：</p>
<div class="codehilite"><pre><span></span>def verify_request(self, request, client_address):
    return True
</pre></div>


<p>这个方法显然留给子类去覆写的。</p>
<p>下面来看process_request方法和相关的几个方法的代码：</p>
<div class="codehilite"><pre><span></span>def process_request(self, request, client_address):
    self.finish_request(request, client_address)
    self.shutdown_request(request)

def finish_request(self, request, client_address):
    self.RequestHandlerClass(request, client_address, self)

def shutdown_request(self, request):
    self.close_request(request)

def close_request(self, request):
    pass
</pre></div>


<p>这里的逻辑是非常简单的，处理请求的流程是：</p>
<ol>
<li>调用处理类处理请求 -&gt; RequestHandlerClass</li>
<li>关闭请求 -&gt; shutdown_request -&gt; close_request</li>
</ol>
<p>close_request显然也是留给子类去实现的，在TCPServer中我们已经见过了它的覆写：</p>
<div class="codehilite"><pre><span></span>def close_request(self, request):
    request.close()
</pre></div>


<p>即关闭与此次请求的客户端的socket连接。</p>
<h3>BaseServer总结</h3>
<p>看到这里我们可以发现，BaseServer最重要的是提供了服务端运行的流程框架，这个流程可以概括为：</p>
<div class="codehilite"><pre><span></span>while &lt;不需要关闭&gt;:
    &lt;监听客户端请求&gt;
    &lt;获取请求&gt;
    &lt;验证请求&gt;
    &lt;调用处理类进行处理&gt;
    &lt;关闭请求&gt;
</pre></div>


<p>除了<code>&lt;监听客户端请求&gt;</code>这一过程是使用<code>select.select</code>来实现，<code>&lt;获取请求&gt;</code>、<code>&lt;验证请求&gt;</code>、<code>&lt;关闭请求&gt;</code>这几个过程，都是在TCPServer中通过socket来具体实现的。</p>
<p>这样的设计方式，在设计模式中称为<code>模板方法</code>，即父类提供大概的流程框架，子类负责具体流程的实现。</p>
<p>我们可以设想有一个大型商场，在它刚刚建造完工之后，虽然已经规划标明了一层是化妆品、二层是服装鞋帽、三层是母婴用品、四层是饮食、电梯在某某位置、卫生间在某某位置，但是这时候具体的商家还没有入住，顾客来到商场会发现，表明化妆品的地方并没有化妆品的柜台，去服装的房间也并没有衣服卖，去餐饮区也没有食物，电梯间并没有电梯，去卫生间也看不到马桶...。这样状态的商场，可以认为是提供了“框架”。</p>
<p>等到商场完成了精装修和商家入驻，正式对外营业的时候，顾客再进来就会发现可以在一层买到化妆品、四层可以吃饭、上下楼有电梯、也可以去卫生间方便了...。这些具体的服务，服饰商家、餐厅、电梯、马桶等，就可以看做是子类。</p>
<p>关于<code>&lt;调用处理类进行处理&gt;</code>这一过程，参看另外一篇文章的讨论。</p>
        </div>
    </div>
</body>
</html>