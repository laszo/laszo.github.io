<html>
<head>
    <meta charset="utf-8">
    <title>Python中的迭代器（iterator） - Lv Xiaoyu `Site</title>
    <link rel="stylesheet" href="../../static/css/mp.css?v=1" />
    <link rel="stylesheet" href="../../static/css/bootstrap.min.css?v=1" />
</head>
<body>
    <div class="container">
        <div class="blog-header">
            <a href="../../index.html"><h1>Lv Xiaoyu `Site</h1></a>
        </div>

        <h3 class="blog-post-title">Python中的迭代器（iterator）</h3>

        <div class="post-content">
            <p>循环可以说是任何一门程序语言中都必备的基本功能，进一步的，很多当代语言提供了迭代器（iterator）的概念，用于在序列（Sequences）类型、或者可以转换为序列的类型上进行循环。比如下面的代码：</p>
<pre><code>foo = [3, 4, 5, 6]
for i in foo:
    print i
</code></pre>
<p>在上面代码中，<code>foo</code>是一个list对象，我们使用了最常见的<code>for in</code>语句来遍历它的成员。除此之外，还可以使用迭代器（<a href="https://docs.python.org/2.7/tutorial/classes.html#iterators">Iterators</a>）来进行遍历。首先用内置函数<a href="https://docs.python.org/2.7/library/functions.html#iter">iter</a>得到foo的迭代器：</p>
<pre><code>&gt;&gt;&gt; it = iter(foo)
</code></pre>
<p>通过dir函数查看迭代器it的属性：</p>
<pre><code>&gt;&gt;&gt; dir(it)
['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__hash__'
, '__init__', '__iter__', '__length_hint__', '__new__', '__reduce__', '__reduce_ex__
', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'next']
</code></pre>
<p>我们关注其中的两个方法：</p>
<ul>
<li>
<p><code>__iter__</code>：这个方法返回一个迭代器，对于已经是迭代器的对象来说，它返回自身。</p>
</li>
<li>
<p><code>next</code>：返回制定序列的下一个元素，如果next第一次被调用，返回的是序列中的第一个元素。</p>
</li>
</ul>
<p>能够提供上述两个方法的对象，我们就可以称之为迭代器。</p>
<p>那么我们当然可以定义自己的迭代器类型：</p>
<pre><code>class MyIntIterator(object):
    def __init__(self, num):
        self.number = num

    def __iter__(self):
        return self

    def next(self):
        self.number += 2
        if self.number &gt; 9:
            raise StopIteration
        return self.number
</code></pre>
<p>这里定义了一个简单的迭代器类型，<code>__init__</code>方法用于接收初始化参数，保存在对象的<code>number</code>属性中。<code>__iter__</code>方法直接返回自身，<code>next</code>把当前的<code>number</code>属性加上2并返回，当<code>number</code>大于9时抛出<code>StopIteration</code>异常。下面来测试一下这个类：</p>
<pre><code>&gt;&gt;&gt; foo = MyIntIterator(2)
&gt;&gt;&gt; foo.next()
4
&gt;&gt;&gt; foo.next()
6
&gt;&gt;&gt; foo.next()
8
&gt;&gt;&gt; foo.next()
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
File "t1.py", line 58, in next
    raise StopIteration
StopIteration
</code></pre>
<p>第一次运行<code>foo.next()</code>返回4，第二次返回6，第三次返回8，运行到第四次时<code>number</code>已经等于10，大于9符合StopIteration的条件，于是抛出异常。</p>
<p>我们同样也可以使用<code>for in</code>语句来进行遍历：</p>
<pre><code>&gt;&gt;&gt; bar = MyIntIterator(2)
&gt;&gt;&gt; for i in bar:
...     print i
...
4
6
8
&gt;&gt;&gt;
</code></pre>
<p>同样返回了4、6、8三个数字。不同的是，程序没有抛出StopIteration异常，而是运行到8之后就停止了遍历。</p>
<p>我们可以认为，<code>for in</code>语句是可用迭代器的方式等价转换的，比如本文一开始的代码：</p>
<pre><code>foo = [3, 4, 5, 6]
for i in foo:
    print i
</code></pre>
<p>可以改写成如下的等价语句：</p>
<pre><code>foo = [3, 4, 5, 6]
it = iter(foo)
while True:
    try:
        i = it.next()
        print i
    except StopIteration:
        break
</code></pre>
<p>这样的写法比直接使用for in语句要麻烦的多，但是却更加接近for in语句的本质含义，正如python文档所说：</p>
<blockquote>
<p>The expression list is evaluated once; it should yield an iterable object. An iterator is created for the result of the expression_list. The suite is then executed once for each item provided by the iterator, in the order of ascending indices. </p>
</blockquote>
<p>上面讨论了迭代器对象，它必须提供<code>__iter__</code>和<code>next</code>两个方法，如果一个对象只有<code>__iter__</code>方法，也是可以对它使用<code>iter()</code>内置函数的，但是该<code>__iter__</code>方法必须返回一个迭代器对象，否则会抛出<code>TypeError</code>异常：</p>
<pre><code>class only_iter(object):
    def __iter__(self):
        return 1
</code></pre>
<p>来测试一下：</p>
<pre><code>&gt;&gt;&gt; foo = only_iter()
&gt;&gt;&gt; iter(foo)
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: iter() returned non-iterator of type 'int'
</code></pre>
<p>这里抛出了<code>TypeError</code>异常。但是我们从中可以看出，内置函数<code>iter()</code>其实就是对指定对象调用<code>__iter__</code>方法，然后检查该方法的返回值，如果返回值不是iterator对象，则抛出<code>TypeError</code>异常，如果是则返回该返回值。</p>
<p>这里我们又忽发奇想，如果一个对象只提供next方法，它是否是一个迭代器呢？我们来写如下的代码：</p>
<pre><code>class next_only(object):
    def next(self):
        return 1

class only_iter(object):
    def __iter__(self):
        return next_only()
</code></pre>
<p>定义一个<code>next_only</code>，只提供next方法，然后定义<code>only_iter</code>类型，提供<code>__iter__</code>方法。下面来进行测试：</p>
<pre><code>&gt;&gt;&gt; foo = only_iter()
&gt;&gt;&gt; bar = iter(foo)
&gt;&gt;&gt; bar
&lt;t1.next_only object at 0x10f194250&gt;
</code></pre>
<p>可以看到，在这样的定义下，对only_iter类型的对象调用内置函数<code>iter()</code>，不会再抛出<code>TypeError</code>异常了，而是返回了一个<code>next_only</code>类型的对象bar。这个对象是否就是迭代器类型呢？</p>
<pre><code>&gt;&gt;&gt; for i in bar:
...     print i
...
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'next_only' object is not iterable
</code></pre>
<p>可以看到，对bar执行 for in语句，又跑出了TypeError异常。看来仅仅提供next方法，虽然可以过iter这一关，但仍然不能算是迭代器类型。</p>
<pre><code>class mnonitercls(object):
    def hi(self):
        print 'hi'

class foocls(object):
    def __iter__(self):
        return barcls(9)

class barcls(object):
    def __init__(self, num):
        self.num = num
    def __iter__(self):
        return self
    def next(self):
        self.num += 1
        if self.num &gt; 15:
            raise StopIteration
        return self.num
</code></pre>
<p>测试：
对mnonitercls的实例调用iter：</p>
<pre><code>&gt;&gt;&gt; mno = mnonitercls()
&gt;&gt;&gt; iter(mno)
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'mnonitercls' object is not iterable
</code></pre>
<p>可以看到，会报错。而对foocls的实例调用iter：</p>
<pre><code>&gt;&gt;&gt; foo = foocls()
&gt;&gt;&gt; f1 = iter(foo)
&gt;&gt;&gt; for i in f1:
...     print i
</code></pre>
<p>不会报错，能够生成迭代器对象。可见所谓的iter函数的主要工作就是调用它的参数的<code>__iter__</code>方法（即便这个方法返回的对象不是iterator对象）。</p>
<pre><code>&gt;&gt;&gt; f1
&lt;t1.barcls object at 0x105c37cd0&gt;
&gt;&gt;&gt; f2 = iter(f1)
&gt;&gt;&gt; f2
&lt;t1.barcls object at 0x105c37cd0&gt;
</code></pre>
<p>iterator对象如果执行next完毕，再执行会抛出异常StopIteration。</p>
<pre><code>&gt;&gt;&gt; f2.next()
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
File "t1.py", line 31, in next
    raise StopIteration
StopIteration
</code></pre>
<p>参考：</p>
<p><a href="https://docs.python.org/2.7/tutorial/classes.html#iterators">Iterators</a></p>
<p><a href="https://docs.python.org/2.7/library/stdtypes.html?highlight=iterator#iterator-types">Iterator Types</a></p>
<p><a href="https://docs.python.org/2.7/reference/compound_stmts.html#the-for-statement">The for statement</a></p>
<p><a href="https://docs.python.org/2.7/library/itertools.html#module-itertools">itertools — Functions creating iterators for efficient looping</a></p>
        </div>
    </div>
</body>
</html>