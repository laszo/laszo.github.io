---
title: 'WSGI的Server端分析'
---

我们都知道写一个WSGI的application是非常简单的：

    def app(env, start_response):
        start_response('200 OK', [('Content-type', 'text/plain')])
        return 'Hello, world!\n'

这篇文章已经探讨了WSGI的application这一部分的特点，现在我们来关心服务器如何承载application，我们从python标准库wsgiref来研究这个过程。虽然wsgiref作为生产环境的服务器是不够的，但是用来研究基本的原理已足够。如下代码就可以运行起server：

    from wsgiref.simple_server import make_server
    s = make_server('', 8000, myapp.app)
    s.serve_forever()

make_server的代码：

    def make_server(
        host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler
    ):
        server = server_class((host, port), handler_class)
        server.set_app(app)
        return server

核心是`WSGIServer`和`WSGIRequestHandler`两个类。先从Server来看：

    class WSGIServer(HTTPServer):

        """BaseHTTPServer that implements the Python WSGI protocol"""

        application = None

        def server_bind(self):
            """Override server_bind to store the server name."""
            HTTPServer.server_bind(self)
            self.setup_environ()

        def setup_environ(self):
            # Set up base environment
            env = self.base_environ = {}
            env['SERVER_NAME'] = self.server_name
            env['GATEWAY_INTERFACE'] = 'CGI/1.1'
            env['SERVER_PORT'] = str(self.server_port)
            env['REMOTE_HOST']=''
            env['CONTENT_LENGTH']=''
            env['SCRIPT_NAME'] = ''

        def get_app(self):
            return self.application

        def set_app(self,application):
            self.application = application

其继承自`BaseHTTPServer.HTTPServer`，添加了如下几个方法：

* get_app和set_app：设置或获取application
* server_bind，使用的是父类的server_bind，多执行了setup_environ这一步
* setup_environ，设置env变量的一些基本字段，保存在自己的base_environ成员中

追踪到`HTTPServer`:

    class HTTPServer(SocketServer.TCPServer):

        allow_reuse_address = 1    # Seems to make sense in testing environment

        def server_bind(self):
            """Override server_bind to store the server name."""
            SocketServer.TCPServer.server_bind(self)
            host, port = self.socket.getsockname()[:2]
            self.server_name = socket.getfqdn(host)
            self.server_port = port

继承自`SocketServer.TCPServer`，只添加了一个方法`server_bind`。这方法先是调用其父类的同名方法`TCPServer.server_bind`，然后设置了自身的server_name和server_port成员。

到这里可以发现，从`WSGIServer`到`BaseHttpServer`，并不包含什么处理流程，要研究的东西还在后面。来看TCPServer，由于它的代码太多，我们一部分一部分来研究：

class TCPServer(BaseServer):

    def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True):
        BaseServer.__init__(self, server_address, RequestHandlerClass)
        self.socket = socket.socket(self.address_family, self.socket_type)
        if bind_and_activate:
            try:
                self.server_bind()
                self.server_activate()
            except:
                self.server_close()
                raise

TCPServer继承自BaseServer，它的构造方法做了如下几件事：

* 调用父类BaseServer的构造器，传入地址和处理类，也就是说到了Baserver的代码层面是知道处理类的存在的
* 初始化它的成员socket
* 如果bind_and_activate为True（默认为True），调用server_bind和server_activate，看名字就知道，分别是绑定和激活服务器

来看server_bind：

    def server_bind(self):
        if self.allow_reuse_address:
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket.bind(self.server_address)
        self.server_address = self.socket.getsockname()

核心逻辑是执行socket.bind，这是使用socket必要的第一步。其次是把地址存储在自身的server_address成员上。

来看server_activate：

    def server_activate(self):
        self.socket.listen(self.request_queue_size)

单纯执行socket.listen。看到这里我们可以发现，TCPServer的构造方法，除了调用父类的构造方法之外，主要就是完成了对socket的初始化和监听，相当于：

    self.socket = socket.socket()
    self.socket.bind(address)
    self.socket.listen(self.request_queue_size)

这几个方法看完，我们一次性的看TCPServer的其他方法：

    def server_close(self):
        self.socket.close()

    def fileno(self):
        return self.socket.fileno()

    def get_request(self):
        return self.socket.accept()

    def shutdown_request(self, request):
        try:
            request.shutdown(socket.SHUT_WR)
        except socket.error:
            pass
        self.close_request(request)

    def close_request(self, request):
        request.close()

`server_close`和`fileno`这两个方法，就是纯粹调用自身socket成员的对应方法。
`shutdown_request`和`close_request`，分别调用socket的`shutdown`和`close`方法。
至于`get_request`，则是返回了socket的accept方法的返回值，我们知道这是一个pair：(conn, address)：

* coon，是一个新的socket对象，代表原来的socket与另一端（客户端）的连接
* address，代表另一端的地址

到这里TCPServer的代码就看完了，我们可以说，它其实只有如下几点：

* 就是对socket的一层包装
* 附加了简单的错误处理
* 存储部分对象

至于我们最关心的服务端的处理流程，看来还要进一步再往下看`BaseServer`，仍然分为几个部分来看：

    class BaseServer:
        def __init__(self, server_address, RequestHandlerClass):
            self.server_address = server_address
            self.RequestHandlerClass = RequestHandlerClass
            self.__is_shut_down = threading.Event()
            self.__shutdown_request = False

BaseServer终于没有再继承其他类了，它的构造方法做了如下几件事：

* 存储server_address和RequestHandlerClass成员
* 调用`threading.Event`，这个方法生成了一个新的Event对象，用于在线程间传输信号，我们可以推论BaseServer使用了多线程
* 初始化__shutdown_request为False

到这里，似乎没有了追踪的线索。我们可以回溯到最初的代码：

    from wsgiref.simple_server import make_server
    s = make_server('', 8000, myapp.app)
    s.serve_forever()

Server调用了`serve_forever`方法，就从这里来吧：

    def serve_forever(self, poll_interval=0.5):
        self.__is_shut_down.clear()
        try:
            while not self.__shutdown_request:
                r, w, e = _eintr_retry(select.select, [self], [], [], poll_interval)
                if self in r:
                    self._handle_request_noblock()
        finally:
            self.__shutdown_request = False
            self.__is_shut_down.set()


这个方法的作用可以从它的第一句注释总结：

>
Handle one request at a time until shutdown.
（每次处理一个请求，直到关闭。）

这句话也说明了代码的逻辑。（另有一句话：If you need to do periodic(定期的) tasks, do them inanother thread. 待办）

`_eintr_retry`其实就是循环调用方法并处理异常。

    def _eintr_retry(func, *args):
        """restart a system call interrupted by EINTR"""
        while True:
            try:
                return func(*args)
            except (OSError, select.error) as e:
                if e.args[0] != errno.EINTR:
                    raise
