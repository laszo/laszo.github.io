---
title: "Django Model 层工作流总结"
---

Model层是Django框架的基础部分之一，本文试图总结有关Model层操作的相关代码，包括数据库连接、
配置信息、API操作，以 MySQL 和 Django 1.10 为例。

#### 数据库连接

当我们使用如下这样的命令创建了新的Django项目之后:

    django-admin startproject myproject;
    cd myproject;
    django-admin startapp myapp;

Django 为我们配置了默认的数据库连接，在文件 myproject/settings.py 下，默认使用 sqlite：

    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
        }
    }

实际的生产环境中很少用到sqlite，我们把它更改为使用 MySQL ：

    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.mysql',
            'HOST': 'YOURHOST',
            'USER': 'YOURUSER',
            'PASSWORD': 'YOURPASSWORD',
            'NAME': 'YOURDATABASE',
        }
    }

这里的`NAME`项指的是数据库名，`HOST`、`USER`、`PASSWORD` 这几项按照具体环境信息填写即可。
然后我们可以在项目目录下运行:

    python manage.py check

如果数据库配置有问题，会有相应的错误提示，如果完全配置正确，会有如下的信息显示：

    System check identified no issues (0 silenced).

然后我们可以进行下一步。

### Model 定义

在上面的 `django-admin startapp myapp` 命令下，
Django 已经为我们设置好了 `myapp` 项目的架构，
其中 Model 的定义代码可以放在项目目录的 `myapp/models.py` 文件下。

假设我们要开发一个类似于 [Pinterest] 的网站。现在姑且先定义两个Model，User 和 Pin :

    from django.db import models

    class User(models.Model):
        name = models.fields.CharField(max_lenth=128)
        avatar = models.fields.URLField()

    class Pin(models.Model):
        src = models.fields.URLField()
        intro = models.fields.CharField()

定义的 Model 必须继承自 `django.db.models.Model`，然后按照业务逻辑需要定义相关字段即可。
Django 的 Model 层已经提供了常见的字段类型，具体可见 [Django Model field reference]。

### Django migration

在实际的Web开发中，需要将业务网代码中的 Model 与数据库中的表一一对应，
Model 的每一个属性对应数据表的每一个字段。
如果存在某种机制，当我们在代码里定义了 Model 以后，它能够帮我们在数据库里自动生成相关的表，
更进一步的，如果对 Model 进行了一些改动，比如增删字段、修改字段名等，
它还能够帮我们对数据库进行相应的改动，这肯定将会大大节省我们的工作量，
并且还避免了手动键入代码有可能会出现的错误。很多成熟的Web框架都提供了这种机制。

在 Django 框架里，把这样的机制称为 `migration`，分为两步：

1. 生成 migration，
2. 执行 migration。

有如下几条相关命令：

* `makemigrations` 顾名思义就是生成所谓的 migration ，每次对 Model 层做出改动，都应该执行这条命令，生成一个新的 migration。

* `showmigrations` 查看所有的 migration 及其状态，包括已执行的和未执行的。

* `sqlmigrate` 查看某一项  migration 所对应的 sql 语句。

* `migrate` 执行 migration ，这一步是实际执行的过程，Django 框架帮助你在数据库里执行相关的sql语句。

下面来具体执行一下。在上面我们已经定义了Model，还需要在 `myproject/settings.py` 
文件中的 `INSTALLED_APPS` 列表中加上 `'myapp.apps.MyappConfig'`：

    INSTALLED_APPS = [
        'myapp.apps.MyappConfig',
        'django.contrib.admin',
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.messages',
        'django.contrib.staticfiles',
    ]

然后只要在项目目录下运行如下命令：
    
    python manage.py makemigration

得到输出：

    Migrations for 'myapp':
    myapp/migrations/0001_initial.py:
        - Create model Pin
        - Create model User

该命令在 `myapp/migrations/` 文件夹下生成了一个 `0001_initial.py`，在 Django 中，
该文件夹下的每个 py 文件都被看做一个 `migration`，每个文件中都需要定义一个继承自
`django.db.migrations.Migration` 的类，命名为 `Migration`，
稍微研究一下即可明白它的语法，这里不再赘述。

如果我们想看当前的项目下有哪些 migration，可以运行如下命令：

    python manage.py showmigrations

可以看到输出：

    admin
    [ ] 0001_initial
    [ ] 0002_logentry_remove_auto_add
    auth
    [ ] 0001_initial
    [ ] 0002_alter_permission_name_max_length
    [ ] 0003_alter_user_email_max_length
    [ ] 0004_alter_user_username_opts
    [ ] 0005_alter_user_last_login_null
    [ ] 0006_require_contenttypes_0002
    [ ] 0007_alter_validators_add_error_messages
    [ ] 0008_alter_user_username_max_length
    contenttypes
    [ ] 0001_initial
    [ ] 0002_remove_content_type_name
    myapp
    [ ] 0001_initial
    sessions
    [ ] 0001_initial

其中，除了

    myapp
    [ ] 0001_initial

是我们自己创建的模型所生成的 migration，其余的都是 Django 框架自行设置的 middleware 所使用的相关模型，将来我们说到 middleware 时再去研究。

然后，我们既可以直接执行 `migrate`，也可以先执行 `sqlmigrate` 看一下某一个 migration 所代表的SQL语句。

    python manage.py sqlmigrate myapp 0001_initial

`sqlmigrate` 这条命令需要两个参数，第一个参数 `myapp` 是需要指定的 app 名字，第二个参数 `0001_initial` 是该 app 下的指定 migration 的名字。得到输出：

    BEGIN;
    --
    -- Create model Pin
    --
    CREATE TABLE `myapp_pin` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `src` varchar(200) NOT NULL, `intro` varchar(128) NOT NULL);
    --
    -- Create model User
    --
    CREATE TABLE `myapp_user` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `name` varchar(128) NOT NULL, `avatar` varchar(200) NOT NULL);
    COMMIT;

这是标准的SQL语句，创建了两个表 `myapp_pin` 和 `myapp_user` 。这说明，migration 所生成的表名就是 `app名_Model名` 的格式。

虽然我们并没有在 Model 里定义 id 属性，migration 还是自动给我们生成了一个 标准的 id 字段作为主键[^note1]。

下面该执行 `migrate` 了：

    python manage.py migrate

可以看到如下输出：

    Operations to perform:
        Apply all migrations: admin, auth, contenttypes, myapp, sessions
    Running migrations:
        Applying contenttypes.0001_initial... OK
        Applying auth.0001_initial... OK
        Applying admin.0001_initial... OK
        Applying admin.0002_logentry_remove_auto_add... OK
        Applying contenttypes.0002_remove_content_type_name... OK
        Applying auth.0002_alter_permission_name_max_length... OK
        Applying auth.0003_alter_user_email_max_length... OK
        Applying auth.0004_alter_user_username_opts... OK
        Applying auth.0005_alter_user_last_login_null... OK
        Applying auth.0006_require_contenttypes_0002... OK
        Applying auth.0007_alter_validators_add_error_messages... OK
        Applying auth.0008_alter_user_username_max_length... OK
        Applying myapp.0001_initial... OK
        Applying sessions.0001_initial... OK

每个 migration 都顺利执行了。这时候如果再次执行 `showmigrations` ：

    python manage.py showmigrations

可以看到跟刚才不一样的输出：

    admin
    [X] 0001_initial
    [X] 0002_logentry_remove_auto_add
    auth
    [X] 0001_initial
    [X] 0002_alter_permission_name_max_length
    [X] 0003_alter_user_email_max_length
    [X] 0004_alter_user_username_opts
    [X] 0005_alter_user_last_login_null
    [X] 0006_require_contenttypes_0002
    [X] 0007_alter_validators_add_error_messages
    [X] 0008_alter_user_username_max_length
    contenttypes
    [X] 0001_initial
    [X] 0002_remove_content_type_name
    myapp
    [X] 0001_initial
    sessions
    [X] 0001_initial

每个 migration 前面的 `[ ]` 变成了 `[X]` 。这代表这个 migration 的状态从未执行变成了已执行。

[^note1]: 我们在探索 Django 框架的各个模块时都能感觉到，对于我们在 Web 系统的开发实践中涉及到的各项任务，Django 尽量把其中能够自动化、标准化的重复劳动提取出来，用业内比较成熟的做法自动的替我们完成，这是它区别于其他 Web 框架的一个特点。

[Pinterest]: http://pinterest.com/
[Django Model field reference]: https://docs.djangoproject.com/en/1.10/ref/models/fields/
